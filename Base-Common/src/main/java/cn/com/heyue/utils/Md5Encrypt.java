package cn.com.heyue.utils;import org.apache.commons.codec.digest.DigestUtils;import java.io.UnsupportedEncodingException;import java.security.MessageDigest;import java.security.NoSuchAlgorithmException;import java.security.SignatureException;import java.util.Arrays;/** * MD5工具类 * * @author 宋维 * @version V1.0 */public class Md5Encrypt {    private static java.util.Map<String, String> md5StrMap =            new java.util.concurrent.ConcurrentHashMap<String, String>(500);    /**     * 对字符串进行MD5签名     *     * @param text 明文     * @return 密文     */    public static String md5(String text, String input_charset) {        return DigestUtils.md5Hex(getContentBytes(text, input_charset));    }    /**     * @param content     * @param charset     * @return     * @throws SignatureException     * @throws UnsupportedEncodingException     */    private static byte[] getContentBytes(String content, String charset) {        if (charset == null || "".equals(charset)) {            return content.getBytes();        }        try {            return content.getBytes(charset);        } catch (UnsupportedEncodingException e) {            throw new RuntimeException("MD5签名过程中出现错误,指定的编码集不对,您目前指定的编码集是:" + charset);        }    }    public static String md5_hisun(String text, String key) {        String value = cryptMd5(text, "");        String sign = cryptMd5(value, key);        return sign;    }    public static String cryptMd5(String source, String key) {        byte[] k_ipad = new byte[64];        byte[] k_opad = new byte[64];        byte[] keyb;        byte[] value;        try {            keyb = key.getBytes("UTF-8");            value = source.getBytes("UTF-8");        } catch (UnsupportedEncodingException var10) {            keyb = key.getBytes();            value = source.getBytes();        }        Arrays.fill(k_ipad, keyb.length, 64, (new Integer(54)).byteValue());        Arrays.fill(k_opad, keyb.length, 64, (new Integer(92)).byteValue());        for(int i = 0; i < keyb.length; ++i) {            k_ipad[i] = (byte)(keyb[i] ^ 54);            k_opad[i] = (byte)(keyb[i] ^ 92);        }        MessageDigest md = null;        try {            md = MessageDigest.getInstance("MD5");        } catch (NoSuchAlgorithmException var9) {            return null;        }        md.update(k_ipad);        md.update(value);        byte[] dg = md.digest();        md.reset();        md.update(k_opad);        md.update(dg, 0, 16);        dg = md.digest();        return toHex(dg);    }    public static String toHex(byte[] input) {        if (input == null) {            return null;        } else {            StringBuffer output = new StringBuffer(input.length * 2);            for(int i = 0; i < input.length; ++i) {                int current = input[i] & 255;                if (current < 16) {                    output.append("0");                }                output.append(Integer.toString(current, 16));            }            return output.toString();        }    }    public static void main(String[] args) {        System.out.println(Md5Encrypt.md5("188071695741470968836960", "utf-8").toUpperCase());        md5StrMap.put("1", "11");        md5StrMap.put("1", "22");        System.out.println(md5StrMap.size() + "," + md5StrMap.get("3"));    }}